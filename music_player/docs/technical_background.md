# 技術解説：10バンド・イコライザーの数学的背景と実装
**Project: Music Player (Provisional) - DSP Engine**

## 1. はじめに
本プロジェクトのイコライザー（EQ）は、オーディオ信号処理におけるデファクトスタンダードである **2次IIRフィルタ（バイカッド・フィルタ）** を採用しています。本資料では、その数学的モデルおよび Python での高速化戦略について解説します。

---

## 2. 数学的モデル：バイカッド・フィルタ
デジタル領域におけるフィルタの挙動は、 $z$ 領域の転達関数 $H(z)$ によって定義されます。

$$H(z) = \frac{b_0 + b_1z^{-1} + b_2z^{-2}}{a_0 + a_1z^{-1} + a_2z^{-2}}$$

これを時間領域の **差分方程式** に変換すると、現在の出力信号 $y[n]$ は以下の式で求められます。

$$y[n] = \frac{1}{a_0} \left( b_0 x[n] + b_1 x[n-1] + b_2 x[n-2] - a_1 y[n-1] - a_2 y[n-2] \right)$$

ここで $x[n]$ は入力信号、 $x[n-1], y[n-1]$ 等は過去の入出力サンプル（遅延要素）を指します。

---

## 3. ピーキングEQの設計アルゴリズム
10バンドEQの各バンドには、中心周波数 $f_c$ 付近のみを増幅・減衰させる **ピーキング・フィルタ** を使用します。係数の算出には、Robert Bristow-Johnson's Cookbook のアルゴリズムを採用しています。

### 3.1 中間パラメータ
計算の共通要素として以下の値を定義します。

* **ゲインの線形化**: $A = 10^{\frac{Gain_{dB}}{40}}$
* **角周波数**: $\omega_0 = \frac{2\pi f_c}{f_s}$ （ $f_s$ : サンプリングレート）
* **帯域幅（Q値）**: $\alpha = \frac{\sin(\omega_0)}{2Q}$

### 3.2 フィルタ係数の定義
$$b_0 = 1 + \alpha A$$
$$b_1 = -2 \cos(\omega_0)$$
$$b_2 = 1 - \alpha A$$
$$a_0 = 1 + \frac{\alpha}{A}$$
$$a_1 = -2 \cos(\omega_0)$$
$$a_2 = 1 - \frac{\alpha}{A}$$

実装時は全ての係数を $a_0$ で除算（正規化）し、演算効率を最適化します。

---

## 4. Pythonにおけるパフォーマンス最適化
C++ 等のネイティブ言語と比較してオーバーヘッドが大きい Python において、リアルタイム処理を実現するために以下の戦略を導入しています。

### 4.1 Numba による JIT コンパイル
フィルタ演算はサンプルごとの再帰的な計算（ $y[n-1]$ 等への依存）を伴うため、純粋な Python の `for` ループではボトルネックとなります。
本実装では `Numba` の `@jit(nopython=True)` を使用し、この差分方程式を LLVM 経由で機械語へコンパイルすることで、C++ 実装に肉薄する計算速度を確保しています。

### 4.2 NumPy によるベクトル演算
信号のバッファリングには `NumPy` を採用し、メモリレイアウトを C 言語互換（C-contiguous）に固定することで、SIMD 命令による高速化の恩恵を最大限に引き出します。

### 4.3 ダイレクトフォーム II (Transposed Direct Form II)
浮動小数点の丸め誤差を最小化し、内部状態保持用のメモリを 2 要素（ $w_1, w_2$ ）に抑えるため、転置ダイレクトフォーム II 型構造を採用しています。

---

## 5. 参考文献
* Robert Bristow-Johnson, "Cookbook formulae for audio equalizer biquad filter coefficients"
* Julius O. Smith, "Introduction to Digital Filters with Audio Applications"